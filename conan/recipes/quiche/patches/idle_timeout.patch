diff --git a/include/quiche.h b/include/quiche.h
index 59ab5a3..7f39229 100644
--- a/include/quiche.h
+++ b/include/quiche.h
@@ -329,6 +329,10 @@ uint64_t quiche_conn_timeout_as_nanos(quiche_conn *conn);
 // Returns the amount of time until the next timeout event, in milliseconds.
 uint64_t quiche_conn_timeout_as_millis(quiche_conn *conn);

+// (Added by AdGuard, this is informational only)
+// Returns the amount of time until the next idle timeout event, in nanoseconds.
+uint64_t quiche_conn_idle_timeout_as_nanos(quiche_conn *conn);
+
 // Processes a timeout event.
 void quiche_conn_on_timeout(quiche_conn *conn);

diff --git a/src/ffi.rs b/src/ffi.rs
index edcf7c1..12ce3fb 100644
--- a/src/ffi.rs
+++ b/src/ffi.rs
@@ -827,6 +827,15 @@ pub extern fn quiche_conn_timeout_as_millis(conn: &mut Connection) -> u64 {
     }
 }

+#[no_mangle]
+pub extern fn quiche_conn_idle_timeout_as_nanos(conn: &mut Connection) -> u64 {
+    match conn.next_idle_event() {
+        Some(timeout) => timeout.as_nanos() as u64,
+
+        None => std::u64::MAX,
+    }
+}
+
 #[no_mangle]
 pub extern fn quiche_conn_on_timeout(conn: &mut Connection) {
     conn.on_timeout()
diff --git a/src/lib.rs b/src/lib.rs
index fb6875a..76e1002 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -4022,6 +4022,27 @@ impl Connection {
         None
     }

+    /// Returns the amount of time until the next idle timeout
+    pub fn next_idle_event(&self) -> Option<time::Duration> {
+        if self.is_closed() {
+            return None;
+        }
+
+        let timeout = self.idle_timer;
+
+        if let Some(timeout) = timeout {
+            let now = time::Instant::now();
+
+            if timeout <= now {
+                return Some(time::Duration::new(0, 0));
+            }
+
+            return Some(timeout.duration_since(now));
+        }
+
+        None
+    }
+
     /// Processes a timeout event.
     ///
     /// If no timeout has occurred it does nothing.
