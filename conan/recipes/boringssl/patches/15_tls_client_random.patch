diff --git a/include/openssl/ssl.h b/include/openssl/ssl.h
index e6ccd145a..54ff2bcc6 100644
--- a/include/openssl/ssl.h
+++ b/include/openssl/ssl.h
@@ -5665,6 +5665,21 @@ OPENSSL_EXPORT int SSL_CTX_set_compliance_policy(
 OPENSSL_EXPORT int SSL_set_compliance_policy(
     SSL *ssl, enum ssl_compliance_policy_t policy);

+#define SSL_set_custom_client_random SSL_set_custom_client_random
+
+// SSL_set_custom_client_random sets a user-specified Client Random value.
+//
+// WARNING: For TLS < 1.3, security may be reduced if the provided ClientRandom
+// is not from a cryptographically secure RNG. In pre-1.3 handshakes,
+// ClientRandom participates in key derivation and must remain unpredictable.
+// TLS 1.3 and QUIC rely on ephemeral key exchange and per-session randomness;
+// when the provided ClientRandom comes from a CSPRNG, this function is safe to use.
+//
+// This function copies |len| bytes from |buf| to set the client random.
+// If |len| < SSL3_RANDOM_SIZE, the remaining bytes are padded with
+// cryptographically secure random data.
+OPENSSL_EXPORT void SSL_set_custom_client_random(
+    SSL *ssl, const uint8_t *data, size_t len);

 // Nodejs compatibility section (hidden).
 //
@@ -6156,6 +6171,7 @@ BSSL_NAMESPACE_END
 #define SSL_R_INVALID_OUTER_EXTENSION 320
 #define SSL_R_INCONSISTENT_ECH_NEGOTIATION 321
 #define SSL_R_INVALID_ALPS_CODEPOINT 322
+#define SSL_R_CUSTOM_CLIENT_RANDOM_NOT_SUPPORTED 323
 #define SSL_R_SSLV3_ALERT_CLOSE_NOTIFY 1000
 #define SSL_R_SSLV3_ALERT_UNEXPECTED_MESSAGE 1010
 #define SSL_R_SSLV3_ALERT_BAD_RECORD_MAC 1020
diff --git a/ssl/handshake_client.cc b/ssl/handshake_client.cc
index 3604836c7..b4da8266c 100644
--- a/ssl/handshake_client.cc
+++ b/ssl/handshake_client.cc
@@ -524,7 +524,19 @@ static enum ssl_hs_wait_t do_start_connect(SSL_HANDSHAKE *hs) {
     }
   }

-  if (!RAND_bytes(ssl->s3->client_random, sizeof(ssl->s3->client_random))) {
+  // Use custom client random if available and TLS 1.3+
+  if (ssl->user_specified_client_random_len != 0 && hs->max_version < TLS1_3_VERSION) {
+    OPENSSL_PUT_ERROR(SSL, SSL_R_CUSTOM_CLIENT_RANDOM_NOT_SUPPORTED);
+    return ssl_hs_error;
+  }
+  auto fill_client_random = [&](uint8_t *buf) -> bool {
+    if (ssl->user_specified_client_random_len != 0) {
+      std::copy_n(ssl->user_specified_client_random, ssl->user_specified_client_random_len, buf);
+      return true;
+    }
+    return RAND_bytes(buf, SSL3_RANDOM_SIZE);
+  };
+  if (!fill_client_random(ssl->s3->client_random)) {
     return ssl_hs_error;
   }
   if (hs->selected_ech_config &&
@@ -1910,6 +1922,12 @@ static enum ssl_hs_wait_t do_finish_client_handshake(SSL_HANDSHAKE *hs) {
     return ssl_hs_error;
   }

+  // At this point version should be negotiated
+  if (ssl->user_specified_client_random_len != 0 && ssl_protocol_version(ssl) < TLS1_3_VERSION) {
+    OPENSSL_PUT_ERROR(SSL, SSL_R_CUSTOM_CLIENT_RANDOM_NOT_SUPPORTED);
+    return ssl_hs_error;
+  }
+
   ssl->method->on_handshake_complete(ssl);

   // Note TLS 1.2 resumptions with ticket renewal have both |ssl->session| (the
diff --git a/ssl/internal.h b/ssl/internal.h
index da9fb6218..44231ec5d 100644
--- a/ssl/internal.h
+++ b/ssl/internal.h
@@ -4015,6 +4015,10 @@ struct ssl_st {
   // renegotiate_mode controls how peer renegotiation attempts are handled.
   ssl_renegotiate_mode_t renegotiate_mode = ssl_renegotiate_never;

+  // This field is used to override client_random
+  uint8_t user_specified_client_random[SSL3_RANDOM_SIZE] = {0};
+  uint8_t user_specified_client_random_len = 0;
+
   // server is true iff the this SSL* is the server half. Note: before the SSL*
   // is initialized by either SSL_set_accept_state or SSL_set_connect_state,
   // the side is not determined. In this state, server is always false.
diff --git a/ssl/ssl_lib.cc b/ssl/ssl_lib.cc
index b1e657646..85c924606 100644
--- a/ssl/ssl_lib.cc
+++ b/ssl/ssl_lib.cc
@@ -3472,3 +3472,20 @@ int SSL_set_compliance_policy(SSL *ssl, enum ssl_compliance_policy_t policy) {
       return 0;
   }
 }
+
+void SSL_set_custom_client_random(SSL *ssl, const uint8_t *data, size_t len) {
+  if (!ssl) {
+    return;
+  }
+
+  size_t copy_len = std::min(len, sizeof(ssl->user_specified_client_random));
+  std::copy_n(data, copy_len, ssl->user_specified_client_random);
+
+  // If provided data is shorter than SSL3_RANDOM_SIZE, pad with random bytes
+  if (copy_len < sizeof(ssl->user_specified_client_random)) {
+    RAND_bytes(ssl->user_specified_client_random + copy_len,
+      sizeof(ssl->user_specified_client_random) - copy_len);
+  }
+
+  ssl->user_specified_client_random_len = SSL3_RANDOM_SIZE;
+}
